---
title: X86上的Android：性能与兼容可否兼得？
date: 2017-02-20 09:26:39
tags:
---



编者按：自从CES2012上Intel发布了针对移动市场的Medfield平台以来，市面上出现过一些基于X86的Android手机。它们甚至能在部分测试中实现单核战双核，双核战四核，那X86手机实际应用情况又真的是这么理想吗？
![](/images/AndroidX86&Armv7/17-26-32-20.jpg)
大部分Android应用都使用基于Dalvik Java代码开发。理论上，由于Dalvik代码在系统的虚拟机中执行，在x86的ATOM平台上不会有性能损失。但由于虚拟机执行效率的有限，对于一些高性能追求的应用，谷歌允许开发者使用原生的C语言代码。而原生代码是针对硬件平台编译，x86，ARM或是MIPS都有其相应的二进制文件。通常来说，针对ARM平台编译的二进制代码，x86的处理器是无法直接运行的。而主流的安卓产品均采用ARM处理器，尽管很早之前，Google的Android NDK就引入了x86编译的选项，但至今还是有相当一部分应用只针对ARM平台进行了编译，这就造成了x86安卓平台兼容性问题。

为了解决这一问题，Intel在推出Android手机系统的ATOM平台之初，就引入了“二进制转换”（Binary Translation）这一功能，来解决x86无法直接运行ARM库的问题。针对ARM编译的二进制代码会被ATOM处理器翻译成x86执行的代码，从而运行包含为ARM编译的原生代码的应用。
![](/images/AndroidX86&Armv7/17-26-34-33.jpg)
通过这一功能，x86 ATOM可以兼容市面上的绝大部分应用。最新的采用Atom Z2580处理器的联想K900已经宣传自己能兼容市场上的TOP 20000应用。

在解决了兼容性问题后，加上x86 Atom单核战双核、双核秒四核的彪悍性能（跑分），x86似乎已毫无黑点，横扫市场指日可待。但遗憾的是，x86所宣传的“兼容”与“性能”，由于目前的生态环境的限制，并不能兼得。

首先我们来简单的看一下目前x86在Android的生态环境情况：
![](/images/AndroidX86&Armv7/17-26-30-22.jpg)
![](/images/AndroidX86&Armv7/17-26-46-20.jpg)
尽管TOP 20000的应用已经可以被兼容，但个人统计了豌豆荚市场中最热门的250个应用，其中31%的应用没有使用原生代码。剩下的69%含有原生代码的应用中，只有8%包含了x86库，剩下61%只有ARM原生库。也就是说，只有这8%的应用，x86可以发挥自己的最佳性能，而绝大部分，都需要进行二进制转换去进行兼容。

进一步，在对性能需求较高的游戏应用中，原生代码的使用更加广泛。
![](/images/AndroidX86&Armv7/17-26-31-59.jpg)
![](/images/AndroidX86&Armv7/17-26-47-2.jpg)
通过统计当乐网中最热游戏TOP100，我们发现，只有6%的游戏不含原生库，胜于94%的游戏都含有原生代码。**在这其中，只有5%的游戏含有x86原生库，剩余的将近90%的游戏，都需要Atom处理器通过二进制转换运行为ARM编译的代码。** 
![](/images/AndroidX86&Armv7/17-26-47-94.jpg)
当然，出于对高性能的需求，不少游戏都包含了armv7a的运行库。尽管如此，我手上的联想K800（Atom Z2460）手机也可以通过二进制转换进行执行。但是经过测试，包含Neon SIMD代码的原生库则无法执行。

说了这些，我们明白，相当一部分数量的应用都需要x86通过二进制转换去兼容ARM代码运行。那么，x86性能如此强悍，在兼容执行ARM代码时，表现又如何呢？这是长期以来为Intel和厂商所回避的一个问题。

 

本次测试对象：联想K800手机，算是首款在国内上市的x86手机。处理器为Atom Z2460 1.6GHz，单核双线程，PowerVR SGX540 400MHz GPU。
![](/images/AndroidX86&Armv7/17-26-42-21.jpg)
首先我们清楚安兔兔，这是x86最喜爱的跑分之一。
![](/images/AndroidX86&Armv7/17-26-37-98.jpg)
尽管Z2460只有单个核心，但其得分依旧超过了大部分低主频的双核ARM A9，相比高主频的双核A9/Krait毫不逊色。而采用双核四线程的Z2580更是能向着三万分冲击，直指目前最高端的4+4核处理器。

 

但是，使用ARMv7库后，Z2460的表现不容乐观，总分一下子缩水了三分之二，CPU得分更是跟单核A8差不多…
![](/images/AndroidX86&Armv7/17-26-36-43.jpg)
接下来的一系列测试也显示了同样的情况：当使用x86原生库时，我们可以发现ATOM的单线程性能异常强悍，特别是内存性能
![](/images/AndroidX86&Armv7/17-26-49-7.jpg)

![](/images/AndroidX86&Armv7/17-26-26-58.jpg)
![](/images/AndroidX86&Armv7/17-26-28-77.jpg)
而一旦采用兼容模式，二进制转换运行ARM库，性能就大大下降，1.6GHz的Atom甚至只有1GHz Cortex-A7的水平都不到。
![](/images/AndroidX86&Armv7/17-26-29-10.jpg)
CoreMark也是同样的情况，性能损失相当可观

 

作为兼容的代价，性能损失只是一方面。另一方面则是功耗的增加。在本文的前半部分已经展示过，目前热门游戏很少有x86原生库，为了方便对比测试，我们选取了幽灵古堡（Epic Citadel）应用作为游戏的代表。

Epic Citadel是一个基于虚幻引擎的demo，画面相当精美，光影特效也不错
![](/images/AndroidX86&Armv7/17-26-44-18.jpg)
![](/images/AndroidX86&Armv7/17-26-45-92.jpg)
本次测试我们使用Intel GPA System Analyzer来记录CPU的占用率和手机工作的电流
![](/images/AndroidX86&Armv7/17-26-42-73.jpg)
使用Epic Citadel自带的Benchmark场景进行测试，结果如下
![](/images/AndroidX86&Armv7/17-26-40-85.jpg)
使用x86原生库（上）获得了平均45.9FPS的成绩，而兼容ARM原生库成绩为31.2FPS，大概有30%的差距。

 

同时分析发现，整个过程中，通过二进制转换执行ARM库和原生运行x86库相比，CPU占用率和手机消耗电流上，均有一定的增加。
![](/images/AndroidX86&Armv7/17-26-38-68.jpg)
![](/images/AndroidX86&Armv7/17-26-39-73.jpg)
相比之下，兼容运行ARM库相比原生执行x86代码，成绩下降了30%，平均的CPU占用率从58.9%提高到了73.4%，而平均电流从621mA提高到了717mA，增加了约100mA，相对来说CPU的功耗增加了约400mW，还是相当可观的。

当然CPU占用率只是个侧面反映，由于测试时内核频率调节默认为Ondemand，尽管占用率差异不大，但二进制转换执行ARM代码时，CPU运行在高主频的时间更长，从而导致功耗的增加。

 

最后总结如下，可以看到二进制转换相比原生执行x86代码，损失的性能还是很可观的，在性能诉求的应用中，损失可高达50%以上。在一些游戏类应用中，也会带来约400mW的CPU功耗的增加。
![](/images/AndroidX86&Armv7/17-26-35-6.jpg)
总的来说，x86的Android之路还很漫长，尽管通过Intel和厂商的努力解决了兼容和性能问题，但相对恶劣的生态环境使得性能和兼容不可兼得。但遗憾的是，Intel在今年表示 “手机业务不图销量 只玩高端”“尽管市场上销量最大的是千元手机，但目前还不是英特尔的方向，英特尔旨在做出现在世界上性能最高的手机” ，在一定程度上，相对较低的占有率还是难以引起开发者的注意和调动开发者的积极性，在生态环境的改善上还是令人担忧。
